// Adds optional dev convenience: the 'updateReadme' gradle task,
// which generates README .md and .adoc files at root, from docs/README.src.md,
// inserting values on placeholders.

import groovy.json.JsonOutput
import groovy.json.JsonSlurper

//////////////////////////////////////////////////  Auto-update current version in docs and package.json:

def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
def NPM_BUNDLE_VERSION = PACKAGE_JSON.dependencies.react4xp
def STARTER_VERSION = "${project.version}"
def XP_VERSION = "${xpVersion}"
def PREVIOUS_VERSION = "${PACKAGE_JSON.version}"
def README_SOURCE = "README.src.md"
def TARGET_COMMENT = "USE THIS FILE TO EDIT THE ROOT's README.md! This will generate the actual README.md and README.adoc with placeholder values inserted. Run gradle task before commit: updateReadme - this should autorun when building. Version placeholders: 0.6.3, 7.0.0, 1.0.0 and 0.2.1. Leave this line in place - and if you edit it, remember to also update it in the search/replace target in build.gradle!"
def NEW_COMMENT = "  Autogenerated from source docs/${README_SOURCE} by the 'updateReadme' task in readme.gradle."

task makeAdoc(type: Copy) {
    from("./docs/")
    into("./")
    include(README_SOURCE)
    rename(README_SOURCE, "README.adoc")

    doFirst {
        new File('README.adoc').delete()
    }

    filter {
        String line -> line
        // PLACEHOLDERS
                .replaceAll(TARGET_COMMENT, NEW_COMMENT)
                .replaceAll("###LIB_REACT4XP_VERSION###", rootProject.ext.LIB_REACT4XP_VERSION)
                .replaceAll("###XP_VERSION###", XP_VERSION)
                .replaceAll("###STARTER_VERSION###", STARTER_VERSION)
                .replaceAll("###NPM_BUNDLE_VERSION###", NPM_BUNDLE_VERSION)

        // MD --> ADOC
                .replaceAll(/\[\/\/\]: <> \((.*?)\)/, "// \$1") // Top comment
                .replaceAll(/^# (.*?)$/, "= \$1\n:toc: right") // Main header, adding auto ToC
                .replaceAll(/^## (.*?)$/, "== \$1") // H2-H5
                .replaceAll(/^### (.*?)$/, "=== \$1")
                .replaceAll(/^#### (.*?)$/, "==== \$1")
                .replaceAll(/^##### (.*?)$/, "===== \$1")
                .replaceAll(/<a name="(.*?)"><\/a>/, "\n[[\$1]]") // Explicit anchor IDs
                .replaceAll(/\[(.*?)\]\((.*?)\)/, "link:\$2[\$1]") // Links
                .replaceAll(/^ +```\s*$/, "----") // Indented code block end (inside numbered list)
                .replaceAll(/^ +```(.*?)$/, "+\n[source,\$1,options=\"nowrap\"]\n----") // Indented code block start (inside numbered list)
                .replaceAll(/^```$/, "----") // Source code end
                .replaceAll(/^```(.*?)$/, "[source,\$1,options=\"nowrap\"]\n----") // Source code start
                .replaceAll(/^(\| ?\*?\*?Version \/ tag\*?\*?[\n \|])(.*?)\|$/, "[%header,cols=3]\n|===\n\$1\$2") // Version table header
                .replaceAll(/^\| ?-.*?- ?\|$/, "")
                .replaceAll(/^(\| ?0\.2\.8.*?) ?\|$/, "\$1\n|===") // Version table last line (starts with "0.2.8")
                .replaceAll(/^(\| ?.*?)\|$/, "\$1") // Version table cells
                .replaceAll(/<br\/>/, "{zwsp} +") // Empty lines
                .replaceAll(/<img src="(.*?)" .*? title="(.*?)" width="(.*?)">/, "image:\$1[title=\"\$2\",width=\$3]") // images
    }

    doLast {
        File fh1 = new File('README.adoc')
        def text = fh1.getText('UTF-8')
        text = text.replaceAll(/\n== Table of Contents\n( *- link:.*?\]\n)*\n/, "")
        fh1.delete()
        fh1.write text
        println "Updated README.adoc from docs/$README_SOURCE"
    }

    inputs.file("./docs/" + README_SOURCE)
    outputs.file('README.adoc')
}

task updateReadme(type: Copy) {
    group('Documentation')
    description('Automatically build/update README (both .md and .adoc) from the readme source: docs/README.src.md and insert values into placeholders, e.g. versions. Will OVERWRITE existing readme files at root.')

    from("./docs/")
    into("./")
    include(README_SOURCE)
    rename(README_SOURCE, "README.md")

    doFirst {
        new File('README.md').delete()
    }

    filter {
        String line -> line
        // PLACEHOLDERS
                .replaceAll(TARGET_COMMENT, NEW_COMMENT)
                .replaceAll("###LIB_REACT4XP_VERSION###", rootProject.ext.LIB_REACT4XP_VERSION)
                .replaceAll("###XP_VERSION###", XP_VERSION)
                .replaceAll("###STARTER_VERSION###", STARTER_VERSION)
                .replaceAll("###NPM_BUNDLE_VERSION###", NPM_BUNDLE_VERSION)
    }

    doLast {
        println "Updated README.md from docs/$README_SOURCE"
    }

    inputs.file("./docs/" + README_SOURCE)
    outputs.file('README.md')
}

updateReadme.dependsOn makeAdoc

def readmeUnstaged() {
    def command = "git diff --name-only HEAD"
    // println "Process: ${command}"
    def proc = command.execute()
    proc.waitFor()
    if (proc.exitValue() != 0) {
        throw new GradleException(proc.err.text)
    }
    def stdout = proc.in.text
    def unstagedSource = stdout.split( '\n' ).findAll { it == "docs/README.md" || it == "docs\\README.md" }
    return unstagedSource.size() > 0
}
updateReadme.enabled = true // rootProject.ext.LIB_REACT4XP_VERSION != PREVIOUS_VERSION || readmeUnstaged()



task updatePackageJson() {
    doLast {
        PACKAGE_JSON.version = "$version"
        def pkgJsonFile = new File('package.json')
        // new File('package.json').delete()
        pkgJsonFile.write(JsonOutput.prettyPrint(JsonOutput.toJson(PACKAGE_JSON)) + "\n")
        println "Updated package.json: version --> ${PACKAGE_JSON.version}"
    }
}

task updateVersions() {}
updateVersions.dependsOn += updateReadme
updateVersions.dependsOn += updatePackageJson
